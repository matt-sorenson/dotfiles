#! /usr/bin/env zsh

emulate -L zsh
set -uo pipefail
setopt err_return
setopt typeset_to_unset

local _usage="Usage: concat-video [OPTIONS]

Required:
  -f, --file FILENAME        filename to base concat off of

Options:
  -o, --output <EXTENSION>   output file extension (default: .m4v)
  -c, --crop w:h:x:y         crop to dimensions w:h:x:y
  -t, --trim <SECONDS>       trim intro from 2nd,3rd... in seconds (default: 0)
  -h, --help                 show this help and exit"

local output_ext='.m4v'
local trim=0
local crop
local filename

while (( $# )); do
    case "$1" in
    -f|--file) ;& # fall through
    -o|--output) ;& # fall through
    -c|--crop) ;& # fall through
    -t|--trim)
        if (( $# < 2 )); then
            print-header -e "Missing argument for $1" >&2
            print "${_usage}"
            return 1
        fi

        case "$1" in
        -f|--file) filename="${2}" ;;
        -o|--output) output_ext="${2}" ;;
        -c|--crop) crop="${2}" ;;
        -t|--trim) trim="${2}" ;;
        esac
        shift
        ;;
    -h|--help)
        print "${_usage}"
        return 0
        ;;
    -*)
        print-header -e "Unknown option: ${1}" >&2
        print "${_usage}"
        return 1
        ;;
    *)
        print-header -e "Unknown argument: ${1}" >&2
        print "${_usage}"
        return 1
        ;;
    esac
    shift
done

if [[ ! -v filename ]]; then
    print-header -e '--file is required' >&2
    print "${_usage}"
    return 1
fi

local base=${filename:t}  # Base filename without path
local dir=${filename:A:h} # Absolute path to directory

# Validate filename format
if ! print "${base}" | grep -Eq '^(.*?) *pt\.?([0-9]+)(\..*)$'; then
    print "Could not parse filename for part: ${filename}" >&2
    return 1
fi

# Extract prefix
local prefix
prefix=$(sed -E 's/^(.*?) *pt\.?[0-9]+(\..*)$/\1/' <<< "${base}")

# Prepare output
local outdir="${dir}/converted"
mkdir -p "${outdir}"
local final_filename="${outdir}/${prefix}${output_ext}"

# Gather & sort parts
local files_partlist=()
local f
local -i n
for f in "${dir}/${prefix}"*; do
    case "${f}" in
        *pt.?([0-9]).*)
        n="${${f##*pt.}%%.*}"
        files_partlist+=("${n} ${(q)f}")
        ;;
        *) continue ;;
    esac
done

local old_IFS="${IFS}"
# Sort files_partlist numerically by the numeric prefix (n)
IFS=$'\n' files_partlist=("${(on)files_partlist[@]}")
IFS="${old_IFS}"

local files=()
for f in "${files_partlist[@]}"; do
    files+=("${f#* }")
done
unset files_partlist
unset n

# Build ffmpeg inputs
local cmd=("ffmpeg")
for f in "${files[@]}"; do
    cmd+=(-i "${f}")
done

# Build filter_complex
local filter_complex=''
local -i i=0
for f in "${files[@]}"; do
    # Don't trim the first part.
    local start_trim=$(( i ? trim : 0 ))

    filter_complex="${filter_complex}[$i:v]setpts=PTS-STARTPTS,trim=start=$start_trim"
    [[ -v crop ]] && filter_complex="${filter_complex},crop=$crop"
    filter_complex="${filter_complex}[v$i]; "

    filter_complex="${filter_complex}[$i:a]asetpts=PTS-STARTPTS"
    ((start_trim )) && filter_complex="${filter_complex},atrim=start=$start_trim"
    filter_complex="${filter_complex}[a$i]; "

    i=$((i + 1))
done

# Concatenate streams
local concat_inputs=''
local -i j
for j in $(seq 0 $((i - 1))); do
    concat_inputs="${concat_inputs}[v$j][a$j]"
done
filter_complex="${filter_complex}${concat_inputs}concat=n=$i:v=1:a=1[out]"

# Final ffmpeg command
cmd+=(-filter_complex "${filter_complex}")
cmd+=(-c:v libx264)
cmd+=(-crf 15)
cmd+=(-preset veryslow)
cmd+=(-map '[out]')
cmd+=("${final_filename}")


if ! "${cmd[@]};" then
    local status=$?
    print-header -e "ffmpeg failed with exit code $status"
    return $status
fi

print-header green "âœ… Successfully created ${final_filename}"
