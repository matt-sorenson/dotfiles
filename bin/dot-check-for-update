#!/usr/bin/env zsh
#compdef dot-check-for-update

dot-check-for-update() {
    emulate -L zsh
    set -uo pipefail
    setopt nullglob
    setopt err_return
    setopt typeset_to_unset
    setopt warn_create_global
    unsetopt short_loops

    local _usage="dot-check-for-update [-h|--help][-g|--git][-l|--local][-b|--brew][-d|--doom] [--auto [time-limit-in-hours]]

    Options:
    --auto [limit]      Automatically update dotfiles if they haven't been updated recently

    --dotfiles          Update dotfiles reposito
    --deps              Update \$DOTFILES/deps/* folders
    -l, --local         Update local scripts
    -b, --brew          Update brew
    -d, --doom          Update doom emacs

    --no-dotfiles       Do not update dotfiles repositories
    --no-deps           Do not update \$DOTFILES/deps/* folders
    +g, --no-git        Do not update git repositories
    +l, --no-local      Do not update local scripts
    +b, --no-brew       Do not update brew
    +d, --no-doom       Do not update doom emacs

    -h, --help          Show this help message and exit

    If no flags are provided then it's treated as if all flags are set."

    local auto_limit_in_hours
    local -A flags=(
        ["auto"]=0
        ["dotfiles"]=0
        ['deps']=0
        ["local"]=0
        ["brew"]=0
        ["doom"]=0
        ["local"]=0
    )

    local -A no_flags=(
        ["dotfiles"]=0
        ['deps']=0
        ["local"]=0
        ["brew"]=0
        ["doom"]=0
        ["local"]=0
    )

    local specified_flag=0
    local specified_no_flag=0

    while (( $# )); do
        case $1 in
        -h|--help)
            print "${_usage}"
            return 0
            ;;
        --auto)
            if [[ $# -gt 1 ]]; then
                if [[ $2 == <-> ]]; then
                    if [[ -v auto_limit_in_hours ]]; then
                        print-header -e "Multiple time limits provided."
                        print "${_usage}"
                        return 1
                    fi

                    auto_limit_in_hours="$2"
                    shift
                fi

                auto_limit_in_hours="15"
                flags[auto]=1
            fi
            ;;
        --*)
            if [[ -v flags[${1##--}] ]]; then
                flags[${1##--}]=1
                specified_flag=1
            elif [[ -v no_flags[${1##--no-}] ]]; then
                no_flags[${1##--no-}]=1
                specified_no_flag=1
            else
                print-header -e "Unknown option '$1'"
                print "${_usage}"
                return 1
            fi
            ;;
        +*)
            local arg_list=("${(@s::)1#+}")

            # Process by popping front each time
            while (( ${#arg_list} )); do
                local arg=${arg_list[1]}
                # Pop the front of the list
                arg_list=("${arg_list[@]:1}")

                case $arg in
                    l) argv+=('--no-local') ;;
                    b) argv+=('--no-brew') ;;
                    d) argv+=('--no-doom') ;;
                    *)
                        print-header -e "Unknown option '+$arg'"
                        print "${_usage}"
                        return 1
                        ;;
                esac
            done
            ;;
        -[!-]*)
            local arg_list=("${(@s::)1#-}")

            # Process by popping front each time
            while (( ${#arg_list} )); do
                local arg=${arg_list[1]}
                # Pop the front of the list
                arg_list=("${arg_list[@]:1}")

                case $arg in
                l) argv+=('--local') ;;
                b) argv+=('--brew') ;;
                d) argv+=('--doom') ;;
                *)
                    print-header -e "Unknown option '-$arg'"
                    print "${_usage}"
                    return 1
                    ;;
                esac
            done
            ;;
        *)
            print-header -e "Unknown option '$1'."
            print "${_usage}"
            return 1
            ;;
        esac
        shift
    done

    if (( flags[auto] )); then
        local date_cmd=()
        if command -v gdate > /dev/null; then
            date_cmd=(gdate -d)
        elif date --version >/dev/null 2>&1; then
            date_cmd=(date -d)
        else
            date_cmd=(date -j -f "%Y-%m-%dT%H:%M:%SZ")
        fi

        local time_limit_in_seconds=$(( 60 * 60 * auto_limit_in_hours ))
        local current_time=$(date +%s)
        local cutoff_time=$(( current_time - time_limit_in_seconds ))
        unset current_time

        local -i last_update
        local update_filename="${DOTFILES}/tmp/dotfile-update"
        if [[ -r "${update_filename}" ]]; then
            if ! last_update="$( "${date_cmd[@]}" "$(<"$update_filename")" "+%s" )"; then
                last_update=0
            fi
        else
            last_update=0
        fi

        if (( last_update < cutoff_time )); then
            local RUN_UPDATE
            read -q "RUN_UPDATE?It's been a while, update dotfiles? "
            print ''
            if [[ "${RUN_UPDATE:l}" != "y" ]]; then
                return 0
            fi
        else
            return 0
        fi
    fi
    unset 'flags[auto]'

    local key
    if (( ! specified_flag )); then
        for key in "${(@k)flags}"; do
            if (( ! no_flags[$key] )); then
                flags[$key]=1
            fi
        done
    elif (( specified_no_flag )); then
        for key in "${(@k)flags}"; do
            if (( no_flags[$key] && flags[$key] )); then
                _error -h "Specified flag --no-${key//_/-} but also specified -${key//_/-} or --${key//_/-}, please choose one."
            fi
        done
    fi

    local -i all_true=1
    for key in "${(@k)flags}"; do
        if (( ! flags[$key] )); then
            all_true=0
        fi
    done

    # We use this instead of exiting early so that we can try to update
    # everything even if one fails
    local -i out=0

    if (( flags[dotfiles] )); then
        print-header green "Updating git repositories."
        if [[ -d "${DOTFILES}" ]]; then
            if dot-check-for-update-git -i 2 "${DOTFILES}"; then
                # If hammerspoon exists we may have updated the config while updating
                # the dotfiles, so we need to reload it.
                if command -v "hs" > /dev/null; then
                    print-header green "Reloading hammerspoon"
                    hs -c "hs.reload()"
                fi
            else
                out=1
            fi
        else
            print-header -w "${DOTFILES} does not exist, skipping dotfiles update."
        fi
    fi

    if (( flags[deps] )); then
        local repos_to_update=( "${DOTFILES}"/deps/*(/) ) # ZSH Does handle spaces in the glob correctly.
        local repo quiet
        for repo in "${repos_to_update[@]}"; do
            if [[ $repo == */local ]]; then
                continue
            fi

            if ! dot-check-for-update-git -i 2 "${repo}"; then
                out=1
            fi
        done
    fi

    if [[ flags[brew] -eq 1 && "${OSTYPE}" == darwin* ]]; then
        if command -v "brew" > /dev/null; then
            print-header green "Updating brew."

            if brew update; then
                if ! brew upgrade; then
                    print-header -e -i 2 "brew: Failed to upgrade."
                    out=1
                fi
            else
                print-header -e -i 2 "brew: Failed to update."
                out=1
            fi
        else
            local flag='-w'
            if (( ! specified_flag )); then
                flag='-e'
                out=1
            fi
            print-header "${flag}" -i 2 "brew: 'brew' is not installed."
        fi
    fi

    if (( flags[local] )); then
        if ! dot-check-for-update-git --extra-quiet "${DOTFILES}/local"; then
            out=1
        fi

        # You can specify a local update function in your "$DOTFILES/local/zsh"
        # files or in $DOTFILES/local/bin
        if command -v "dot-check-for-update-local" > /dev/null; then
            if ! dot-check-for-update-local; then
                out=1
            fi
        fi
    fi

    if (( flags[doom] )); then
        local doomemacs_bin="${DOOMEMACS_BIN:-${HOME}/.config/emacs/bin/doom}"
        if command -v "${doomemacs_bin}" > /dev/null; then
            print-header green "Updating doom emacs."

            if ! "${doomemacs_bin}" upgrade --aot --force --color; then
                print-header -e -i 2 "doom emacs failed to upgrade."
                out=1
            fi
        fi
    fi

    # Only update the timestamp if all updates were successful & we didn't
    # skip any updates
    if (( ! out && all_true )); then
        local update_filename="${DOTFILES}/tmp/dotfile-update"
        local current_time
        current_time="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        print -n "${current_time}" >! "${update_filename}"
    fi

    return $out
}

dot-check-for-update "$@"
