#!/usr/bin/env zsh
#compdef dot-check-for-update

dot-check-for-update() {
    emulate -L zsh
    set -uo pipefail
    setopt null_glob
    setopt err_return
    setopt typeset_to_unset
    setopt warn_create_global
    unsetopt short_loops

    local _usage="dot-check-for-update [-h|--help][-g|--git][-l|--local][-b|--brew][-d|--doom] [--auto [time-limit-in-hours]]

Options:
  --auto [limit]      Automatically update dotfiles if they haven't been updated recently
  --no-replace-shell  On success do not replace the shell with a new instance.
                      This is normally used so the shell the user has is updated,
                      but does lose some state.
  -h, --help          Show this help message and exit

Tasks:
  --[no]-dotfiles     Update dotfiles reposito
  --[no]-deps         Update \$DOTFILES/deps/* folders
  -l, --[no-]local    Update local scripts
  -b, --[no-]brew     Update brew
  -d, --[no-]doom     Update doom emacs

If no tasks are provided then it's treated as if all flags are set.
For all tasks the shortflag can use +<flag> to disable similar to --no-<task>."

    local -A flags=(
        ["replace_zsh"]=1
    )

    local -A tasks=(
        ["dotfiles"]=0
        ['deps']=0
        ["local"]=0
        ["brew"]=0
        ["doom"]=0
        ["local"]=0
    )

    local -A no_tasks=(
        ["dotfiles"]=0
        ['deps']=0
        ["local"]=0
        ["brew"]=0
        ["doom"]=0
        ["local"]=0
    )

    local specified_task=0
    local specified_no_task=0

    while (( $# )); do
        case $1 in
        -h|--help)
            print "${_usage}"
            return 0
            ;;
        --auto)
            if [[ $# -gt 1 ]]; then
                if [[ $2 == <-> ]]; then
                    if [[ -v 'flags[auto]' ]]; then
                        --auto provided multiple times.
                        return 1
                    fi

                    flags[auto]=$2
                    shift
                else
                    flags[auto]=15
                fi
            fi
            ;;
        --*)
            if [[ -v tasks[${1##--}] ]]; then
                tasks[${1##--}]=1
                specified_task=1
            elif [[ -v no_tasks[${1##--no-}] ]]; then
                no_tasks[${1##--no-}]=1
                specified_no_task=1
            elif [[ -v flags[${1##--}] ]]; then
                flags[${1##--}]=1
            elif [[ -v flags[${1##--no-}] ]]; then
                flags[${1##--no-}]=0
            else
                print-header -e "Unknown option '$1'"
                print "${_usage}"
                return 1
            fi
            ;;
        +*)
            local arg_list=("${(@s::)1#+}")

            # Process by popping front each time
            while (( ${#arg_list} )); do
                local arg=${arg_list[1]}
                # Pop the front of the list
                arg_list=("${arg_list[@]:1}")

                case $arg in
                    l) argv+=('--no-local') ;;
                    b) argv+=('--no-brew') ;;
                    d) argv+=('--no-doom') ;;
                    *)
                        print-header -e "Unknown option '+$arg'"
                        print "${_usage}"
                        return 1
                        ;;
                esac
            done
            ;;
        -[!-]*)
            local arg_list=("${(@s::)1#-}")

            # Process by popping front each time
            while (( ${#arg_list} )); do
                local arg=${arg_list[1]}
                # Pop the front of the list
                arg_list=("${arg_list[@]:1}")

                case $arg in
                l) argv+=('--local') ;;
                b) argv+=('--brew') ;;
                d) argv+=('--doom') ;;
                *)
                    print-header -e "Unknown option '-$arg'"
                    print "${_usage}"
                    return 1
                    ;;
                esac
            done
            ;;
        *)
            print-header -e "Unknown option '$1'."
            print "${_usage}"
            return 1
            ;;
        esac
        shift
    done

    if [[ -v 'flags[auto]' ]]; then
        local date_cmd=()
        if command -v gdate > /dev/null; then
            date_cmd=(gdate -d)
        elif date --version >/dev/null 2>&1; then
            date_cmd=(date -d)
        else
            date_cmd=(date -j -f "%Y-%m-%dT%H:%M:%SZ")
        fi

        local time_limit_in_seconds=$(( 60 * 60 * ${flags[auto]} ))
        local current_time=$(date +%s)
        local cutoff_time=$(( current_time - time_limit_in_seconds ))
        unset current_time

        local -i last_update
        local update_filename="${DOTFILES}/tmp/dotfile-update"
        if [[ -r "${update_filename}" ]]; then
            if ! last_update="$( "${date_cmd[@]}" "$(<"$update_filename")" "+%s" )"; then
                last_update=0
            fi
        else
            last_update=0
        fi

        if (( last_update < cutoff_time )); then
            local REPLY
            print -n "It's been a while, update dotfiles? "
            read -q
            print ''
            if [[ "${REPLY}" != "y" ]]; then
                return 0
            fi
            unset REPLY
        else
            return 0
        fi
    fi

    local key
    if (( ! specified_task )); then
        for key in "${(@k)tasks}"; do
            if (( ! no_tasks[$key] )); then
                tasks[$key]=1
            fi
        done
    elif (( specified_no_task )); then
        for key in "${(@k)tasks}"; do
            if (( no_tasks[$key] && tasks[$key] )); then
                _error -h "Specified flag --no-${key//_/-} but also specified -${key//_/-} or --${key//_/-}, please choose one."
            fi
        done
    fi
    unset no_tasks

    local -i all_true=1
    for key in "${(@k)tasks}"; do
        if (( ! tasks[$key] )); then
            all_true=0
        fi
    done

    # We use this instead of exiting early so that we can try to update
    # everything even if one fails
    local -i out=0

    if (( tasks[dotfiles] )); then
        print-header green "Updating dotfiles repo."
        if [[ -d "${DOTFILES}" ]]; then
            local dotfiles_starting_commit="$(git rev-parse --short HEAD)"

            if dot-check-for-update-git -i 2 "${DOTFILES}"; then
                # If hammerspoon exists we may have updated the config while updating
                # the dotfiles, so we need to reload it.
                if command -v "hs" > /dev/null; then
                    local dotfiles_ending_commit="$(git rev-parse --short HEAD)"
                    local hs_changes=($(git diff --name-only "$dotfiles_starting_commit" "$dotfiles_ending_commit" -- hammerspoon/))

                    if (( ${#hs_changes} )); then
                        print-header green "Reloading hammerspoon"
                        hs -c "hs.reload()"
                    fi
                fi
            else
                out=1
            fi

            if command -v "dot-zcompile" > /dev/null; then
                print-header green "Compiling zsh files."
                if ! dot-zcompile; then
                    print-header -e -i 2 "Failed to compile zsh files."
                    out=1
                fi
            else
                print-header -w "dot-zcompile not found, skipping zsh compilation."
            fi
        else
            print-header -w "${DOTFILES} does not exist, skipping dotfiles update."
        fi
    fi

    if (( tasks[deps] )); then
        local repos_to_update=( "${DOTFILES}"/deps/*(/) ) # ZSH Does handle spaces in the glob correctly.
        local repo quiet
        for repo in "${repos_to_update[@]}"; do
            if [[ $repo == */local ]]; then
                continue
            fi

            if ! dot-check-for-update-git -i 2 "${repo}"; then
                out=1
            fi
        done
    fi

    if [[ tasks[brew] -eq 1 && "${OSTYPE}" == darwin* ]]; then
        if command -v "brew" > /dev/null; then
            print-header green "Updating brew."

            if brew update; then
                if ! brew upgrade; then
                    print-header -e -i 2 "brew: Failed to upgrade."
                    out=1
                fi
            else
                print-header -e -i 2 "brew: Failed to update."
                out=1
            fi
        else
            local flag='-w'
            if (( ! specified_task )); then
                flag='-e'
                out=1
            fi
            print-header "${flag}" -i 2 "brew: 'brew' is not installed."
        fi
    fi

    if (( tasks[local] )); then
        if ! dot-check-for-update-git --extra-quiet "${DOTFILES}/local"; then
            out=1
        fi

        # You can specify a local update function in your "$DOTFILES/local/zsh"
        # files or in $DOTFILES/local/bin
        if command -v "dot-check-for-update-local" > /dev/null; then
            if ! dot-check-for-update-local; then
                out=1
            fi
        fi
    fi

    if (( tasks[doom] )); then
        local doomemacs_bin="${DOOMEMACS_BIN:-${HOME}/.config/emacs/bin/doom}"
        if command -v "${doomemacs_bin}" > /dev/null; then
            print-header green "Updating doom emacs."

            if ! "${doomemacs_bin}" upgrade --aot --force --color; then
                print-header -e -i 2 "doom emacs failed to upgrade."
                out=1
            fi
        fi
    fi

    # Only update the timestamp if all updates were successful & we didn't
    # skip any updates
    if (( ! out && all_true )); then
        local update_filename="${DOTFILES}/tmp/dotfile-update"
        local current_time
        current_time="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        print -n "${current_time}" >! "${update_filename}"
    fi

    if (( flags[replace_zsh] )); then
        print-header green "Restarting zsh"
        exec zsh
    fi

    return $out
}

dot-check-for-update "$@"
