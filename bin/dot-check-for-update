#!/usr/bin/env zsh
#compdef dot-check-for-update

## This script depends on DOTFILES being set to the path of the dotfiles repo.

function() {
    emulate -L zsh
    set -uo pipefail
    setopt nullglob
    setopt err_return

    local _usage="dot-check-for-update [-h|--help][-g|--git][-l|--local][-b|--brew][-d|--doom]

Options:
  -h, --help          Show this help message and exit
  --dotfiles          Update dotfiles reposito
  --deps              Update \$DOTFILES/deps/* folders
  -l, --local         Update local scripts
  -b, --brew          Update brew
  -d, --doom          Update doom emacs

  --no-dotfiles       Do not update dotfiles repositories
  --no-deps           Do not update \$DOTFILES/deps/* folders
  +g, --no-git        Do not update git repositories
  +l, --no-local      Do not update local scripts
  +b, --no-brew       Do not update brew
  +d, --no-doom       Do not update doom emacs

If no flags are provided then it's treated as if all flags are set."

    local -A flags=(
        ["dotfiles"]=0
        ['deps']=0
        ["local"]=0
        ["brew"]=0
        ["doom"]=0
        ["local"]=0
    )

    local -A no_flags=(
        ["dotfiles"]=0
        ['deps']=0
        ["local"]=0
        ["brew"]=0
        ["doom"]=0
        ["local"]=0
    )

    local specified_flag=0
    local specified_no_flag=0

    while (( $# )); do
        case $1 in
            -h|--help)
                print "${_usage}"
                return 0
                ;;
            --*)
                if [[ -v flags[${1##--}] ]]; then
                    flags[${1##--}]=1
                    specified_flag=1
                elif [[ -v no_flags[${1##--no-}] ]]; then
                    no_flags[${1##--no-}]=1
                    specified_no_flag=1
                else
                    print-header -e "Unknown option '$1'"
                    print "${_usage}"
                    return 1
                fi
                ;;
            +*)
                local arg_list=("${(@s::)1#+}")

                # Process by popping front each time
                while (( ${#arg_list} )); do
                    local arg=${arg_list[1]}
                    # Pop the front of the list
                    arg_list=("${arg_list[@]:1}")

                    case $arg in
                        l) argv+=('--no-local') ;;
                        b) argv+=('--no-brew') ;;
                        d) argv+=('--no-doom') ;;
                        *)
                            print-header -e "Unknown option '+$arg'"
                            print "${_usage}"
                            return 1
                            ;;
                    esac
                done
                ;;
            -[!-]*)
                local arg_list=("${(@s::)1#-}")

                # Process by popping front each time
                while (( ${#arg_list} )); do
                    local arg=${arg_list[1]}
                    # Pop the front of the list
                    arg_list=("${arg_list[@]:1}")

                    case $arg in
                        l) argv+=('--local') ;;
                        b) argv+=('--brew') ;;
                        d) argv+=('--doom') ;;
                        *)
                            print-header -e "Unknown option '-$arg'"
                            print "${_usage}"
                            return 1
                            ;;
                    esac
                done
                ;;
            *)
                print-header -e "Unknown argument '$1'"
                print "${_usage}"
                return 1
                ;;
        esac
        shift
    done

    local key
    if (( ! specified_flag )); then
        for key in "${(@k)flags}"; do
            if (( ! no_flags[$key] )); then
                flags[$key]=1
            fi
        done
    elif (( specified_no_flag )); then
       for key in "${(@k)flags}"; do
            if (( no_flags[$key] && flags[$key] )); then
                _error -h "Specified flag --no-${key//_/-} but also specified -${key//_/-} or --${key//_/-}, please choose one."
            fi
        done
    fi

    local -i all_true=1
    for key in "${(@k)flags}"; do
        if (( ! flags[$key] )); then
            all_true=0
        fi
    done

    # We use this instead of exiting early so that we can try to update
    # everything even if one fails
    local -i out=0

    if (( flags[dotfiles] )); then
        print-header green "Updating git repositories."
        if [[ -d "${DOTFILES}" ]]; then
            if dot-check-for-update-git -i 2 "${DOTFILES}"; then
                # If hammerspoon exists we may have updated the config while updating
                # the dotfiles, so we need to reload it.
                if command -v "hs" > /dev/null; then
                    print-header green "Reloading hammerspoon"
                    hs -c "hs.reload()"
                fi
            else
                out=1
            fi
        else
            print-header -w "${DOTFILES} does not exist, skipping dotfiles update."
        fi
    fi

    if (( flags[deps] )); then
        local repos_to_update=( "${DOTFILES}"/deps/*(/) ) # ZSH Does handle spaces in the glob correctly.
        local repo quiet
        for repo in "${repos_to_update[@]}"; do
            if [[ $repo == */local ]]; then
                continue
            fi

            if ! dot-check-for-update-git -i 2 "${repo}"; then
                out=1
            fi
        done
    fi

    if [[ flags[brew] -eq 1 && "${OSTYPE}" == darwin* ]]; then
        if command -v "brew" > /dev/null; then
            print-header green "Updating brew."

            if brew update; then
                if ! brew upgrade; then
                    print-header -e -i 2 "brew: Failed to upgrade."
                    out=1
                fi
            else
                print-header -e -i 2 "brew: Failed to update."
                out=1
            fi
        else
            local flag='-w'
            if (( ! specified_flag )); then
                flag='-e'
                out=1
            fi
            print-header "${flag}" -i 2 "brew: 'brew' is not installed."
        fi
    fi

    if (( flags[local] )); then
        if ! dot-check-for-update-git --extra-quiet "${DOTFILES}/local"; then
            out=1
        fi

        # You can specify a local update function in your "$DOTFILES/local/zsh"
        # files or in $DOTFILES/local/bin
        if command -v "dot-check-for-update-local" > /dev/null; then
            if ! dot-check-for-update-local; then
                out=1
            fi
        fi
    fi

    if (( flags[doom] )); then
        local doomemacs_bin="${DOOMEMACS_BIN:-${HOME}/.config/emacs/bin/doom}"
        if command -v "${doomemacs_bin}" > /dev/null; then
            print-header green "Updating doom emacs."

            if ! "${doomemacs_bin}" upgrade --aot --force --color; then
                print-header -e -i 2 "doom emacs failed to upgrade."
                out=1
            fi
        fi
    fi

    # Only update the timestamp if all updates were successful & we didn't
    # skip any updates
    if (( ! out && all_true )); then
        local update_filename="${DOTFILES}/tmp/dotfile-update"
        local current_time
        current_time="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        print -n "${current_time}" >! "${update_filename}"
    fi

    return $out
} "$@"
