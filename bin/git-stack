#! /usr/bin/env zsh
#compdef git-stack

git-stack() {
    emulate -L zsh
    set -uo pipefail
    setopt err_return extended_glob null_glob typeset_to_unset warn_create_global
    unsetopt short_loops

    local _usage="Usage: git-stack

Subcommands:
  init      Initialize the stack from the reflog
  push      Push a branch onto the stack
  pop       Pop a branch from the stack
  clear     Clear the stack
  show      Show the stack (default)

init options:
  +c, --no-clear        Do not clear the existing stack before adding to it.

push options:
  -b, --branch <branch> Create a new branch and check it out

  -- <checkout options> Any options after -- will be passed to git checkout

pop options:
  +i, --no-init         Do not initialize the stack if it doesn't exist

  -- <checkout options> Any options after -- will be passed to git checkout

show options:
  -l, --lines <lines>   Show a maximum of <lines> elements of the stack

Common options:
  -c, --clear   Clear the stack before calling the subcommand
  -q, --quiet   Suppress some output messages
  -h, --help    Show this message"

    eval "$(dot-parse-opts --dot-parse-opts-init)"

    flags[clear]=0
    flags[quiet]=0
    flags[help]=0
    flags[init]=0
    short_to_long_flags[c]=clear
    short_to_long_flags[q]=quiet
    short_to_long_flags[h]=help
    short_to_long_flags[i]=init

    option_args[branch]=str
    short_to_long_opts[b]=branch

    options[lines]=10000 # Absurdly large number to show all lines
    option_args[lines]=int:overwrite
    short_to_long_opts[l]=lines

    allow_extra_args=1

    min_positional_count=0
    max_positional_count=2

    local dot_parse_code=0
    dot-parse-opts "$@" || dot_parse_code=$?
    if (( -1 == dot_parse_code )); then # Help was output
        return 0
    elif (( dot_parse_code )); then
        return $dot_parse_code
    fi

    set -- "${positional_args[@]}"

    # find repo root
    local repo_root
    repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        print 'Not a git repository.' >&2
        return 1
    }

    local stack_file="${repo_root}/.ms-popb-stack"

    local subcmd
    if (( $# )); then
        local subcmd="$1"
        shift
    else
        subcmd='show'
    fi

    if [[ "${subcmd}" == 'help' ]]; then
        print "${_usage}"
        return 0
    fi

    if (( flags[clear] )) || [[ $# > 0 && "$1" == 'clear' ]]; then
        if [[ -f "$stack_file" ]]; then
            rm "${stack_file}"

            if (( ! flags[quiet] )); then
                print-header green "Cleared branch stack."
            fi
        elif (( ! flags[quiet] )); then
            print-header yellow "Nothing to clear."
        fi
    fi

    local -a recall_args=()

    if (( flags[quiet] )); then
        recall_args+=('--quiet')
    fi

    # ensure stack file exists
    touch "${stack_file}"

    local current_branch="$(git branch --show-current)"

    case "$subcmd" in
    clear) ;; # no-op as this was handled above
    init)
        if (( ! flags[clear] )) && [[ ! -v flags_set[clear] ]]; then
            git-stack clear "${recall_args[@]}"
        fi

        local -a branch_list=(${(f)"$(
            git log -g HEAD --format="%gs" \
                | grep '^checkout: moving from ' \
                | sed 's/^checkout: moving from //' \
                | awk -F ' to ' 'NF==2 { print $2 }'
        )"})
        # reverse the list, seems to handle spaces fine from testing.
        branch_list=(${(Oa)branch_list[@]})

        local prev_branch="${current_branch}"
        local branch
        local -i count=0
        for branch in "${branch_list[@]}"; do
            if git show-ref --verify --quiet "refs/heads/${branch}"; then
                if [[ "$branch" != "$prev_branch" ]]; then
                    prev_branch="$branch"

                    print "${branch}" >> "${stack_file}"
                    (( count += 1 ))
                fi
            fi
        done

        if (( ! flags[quiet] )); then
            if (( count > 0 )); then
                print-header green "$count branches added to the stack."
            else
                print-header cyan "No branches added to the stack."
            fi
        fi
        ;;
    push)
        if (( ! $# )) && [[ ! -v options[branch] ]]; then
            print-header -e "No branch specified and no branch option provided."
            return 1
        fi

        local do_insert=1
        if [[ -s "${stack_file}" ]]; then
            local last_branch=$(tail -n 1 "${stack_file}")
            if [[ "${last_branch}" = "${current_branch}" ]]; then
                do_insert=0
            fi
        fi

        if (( do_insert )); then
            print "${current_branch}" >> "${stack_file}"
        fi

        local push_args=()
        if [[ -v options[branch] ]]; then
            push_args+=("-b" "${options[branch]}")
        else
            push_args+=("$1")
        fi

        git checkout "${push_args[@]}" "${extra_args[@]}"
        ;;
    pop)
        local target_branch

        if [[ ! -s "${stack_file}" ]]; then
            if [[ ! -v flags_set[init] ]] || (( flags[init] )); then
                print-header cyan "Stack is empty, initializing stack"

                git-stack init "${recall_args[@]}"
            elif git show-ref --quiet --verify refs/heads/master; then
                target_branch=master
                print "${fg_bold[yellow]}No branches in stack, checking out ${fg_bold[cyan]}$target_branch$reset_color" >&2
            elif git show-ref --quiet --verify refs/heads/main; then
                target_branch=main
                print "${fg_bold[yellow]}No branches in stack, checking out ${fg_bold[cyan]}$target_branch$reset_color" >&2
            else
                # Fall back to the last checked out branch
                target_branch="$(git rev-parse --abbrev-ref '@{-1}')"
            fi
        else
            target_branch=$(tail -n 1 "${stack_file}")

            local stack_contents
            stack_contents="$(sed '$d' "${stack_file}")"
            print -n "${stack_contents}" >! "${stack_file}"
            unset stack_contents
        fi

        if [[ "${target_branch}" = "${current_branch}" ]]; then
            if [[ -s "${stack_file}" ]]; then
                git-stack pop --no-init "${recall_args[@]}" -- "${extra_args[@]}"
            else
                print-header green --icon âœ… "You are already on '${target_branch}'"
            fi

            return 0
        fi

        git checkout "${target_branch}" "${extra_args[@]}" || {
            print-header -e "Failed to checkout branch '${target_branch}'"
            return 1
        }
        ;;
    show)
        if (( flags[clear] )); then
            return 0
        fi

        # Show stack
        if [[ -s "${stack_file}" ]]; then
            nl -n rz -w 3 "${stack_file}" | tail -n "${options[lines]}"
        else
            print-header yellow "Branch stack is empty."
        fi
        ;;
    *)
        print-header -e "Invalid subcommand: $subcmd"
        print "${_usage}"
        return 1
        ;;
    esac

    # File exists and is empty
    if [[ -f "${stack_file}" && ! -s "${stack_file}" ]]; then
        rm "${stack_file}" || print "Failed to remove empty stack file: ${stack_file}"
    fi
}

git-stack "$@"
