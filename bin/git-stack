#! /usr/bin/env zsh
#compdef git-stack

git-stack() {
    emulate -L zsh
    set -uo pipefail
    setopt err_return
    setopt typeset_to_unset
    setopt warn_create_global
    setopt extended_glob
    unsetopt short_loops

    local _usage="Usage:
git-stack [-h|--help] [-c|--clear] [-l|--lines <lines>]
git-stack [-h|--help] [-c|--clear] <subcommand> <subcommand_args>

Display the saved branch stack (oldest at the top, newest at the bottom).

Subcommands:
  init  Call 'git-stack-init' with the remaining arguments
  push  Call 'git-pushb' with the remaining arguments
  pop   Call 'git-popb' with the remaining arguments

Base Command:
  -c, --clear           Clear the branch stack
                          If a subcommand is provided after this flag then the stack is cleared and the subcommand is executed
  -h, --help            Show this help message
                          If a subcommand is provided after the flag then --help is passed to the subcommand
  -l, --lines <lines>   Show a maximum of <lines> elements of the stack"

    local args=()
    local subcmd
    local subcmd_args=()
    local -i clear=0
    while (( $# )); do
        if [[ "$1" == 'init' || "$1" == 'pop'|| "$1" == 'push' ]]; then
            subcmd="$1"
            shift
            break
        elif [[ "$1" == '-h' || "$1" == '--help' ]]; then
            subcmd_args+=("$1")
        elif [[ "$1" == '-c' || "$1" == '--clear' ]]; then
            clear=1
        fi
        args+=("$1")
        shift
    done

    if [[ -v subcmd ]]; then
        if (( clear )); then
            git-stack --clear
        fi

        if [[ "$subcmd" == 'init' ]]; then
            git-stack-init "${subcmd_args[@]}" "$@"
        elif [[ "$subcmd" == 'pop' ]]; then
            git-popb "${subcmd_args[@]}" "$@"
        elif [[ "$subcmd" == 'push' ]]; then
            git-pushb "${subcmd_args[@]}" "$@"
        fi
        return
    fi
    # If no subcommand was provided then reset the args to the original args
    set -- "${args[@]}" "$@"
    unset args subcmd subcmd_args clear

    local -i max_lines

    eval "$(dot-parse-opts --dot-parse-opts-init)"

    flags[clear]=0
    flags[quiet]=0
    short_to_long_flags[c]=clear
    short_to_long_flags[q]=quiet

    options[lines]=10000 # Absurdly large number to show all lines
    option_args[lines]=int:overwrite
    short_to_long_opts[l]=lines

    local dot_parse_code=0
    dot-parse-opts "$@" || dot_parse_code=$?
    if (( -1 == dot_parse_code )); then # Help was output
        return 0
    elif (( dot_parse_code )); then
        return $dot_parse_code
    fi

    # Find repo root
    local repo_root
    repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
        print-header -e "Not a git repository.";
        return 1;
    }

    local stack_file="${repo_root}/.ms-popb-stack"

    if (( flags[clear] )); then
        if [[ -f "$stack_file" ]]; then
            rm "${stack_file}"

            if (( ! flags[quiet] )); then
                print-header green "Cleared branch stack."
            fi
        fi
    else
        if [[ ! -s "${stack_file}" ]]; then
            if (( ! flags[quiet] )); then
                print-header yellow "Branch stack is empty."
            fi
        else
            nl -n rz -w 3 "${stack_file}" | tail -n "${options[lines]}"
        fi
    fi
}

git-stack "$@"
